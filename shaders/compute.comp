// vim: syntax=GLSL
#version 430 core

#define PI 3.14159265359
#define LOCAL_SIZE 16 // Make sure to change in main.c

#define LEFT   float( 1.0)
#define CENTER float( 0.0)
#define RIGHT  float(-1.0)

layout (local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

layout (rgba32f, binding = 0) uniform image2D screenTexture;
layout (location = 0) uniform uint frameNumber;
layout (location = 1) uniform uint time;
layout (location = 2) uniform vec2 mousePos;
layout (location = 3) uniform uint mousePressed;
layout (location = 4) uniform uint rightMousePressed;
layout (location = 5) uniform uint resetToCircle;

struct Agent {
    float x;
    float y;
    float angle;
    uint species;
};

layout(std430, binding = 0) buffer AgentBuffer {
    Agent agents[];
};

layout(std140, binding = 1) uniform MovementSettings {
    uint  numAgents;
    float speed;
    float turnRandomness;
    float turnSpeed;
    float sampleAngle;
    float sampleDist;
    uint  debug;
};

layout(std140, binding = 2) uniform SpeciesSettings {
    uvec4 speciesColours[4];
    uint  numSpecies;
};

uint pcg_state_hash(uint seed) {
    uint x = seed + frameNumber + time;
    x += (x << 10u);
    x ^= (x >> 6u);
    x += (x << 3u);
    x ^= (x >> 11u);
    x += (x << 15u);
    return x;
}

float pcg_next(inout uint state, bool normalize_minus_one_to_one) {
    state = state * 1664525u + 1013904223u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    word = (word >> 22u) ^ word;
    if (normalize_minus_one_to_one) {
        float norm = float(word) * (1.0 / 4294967295.0);
        return (norm * 2.0 - 1.0);
    }
    return float(word) / 4294967295.0;
}

vec4 rgba(uint hex) {
    return vec4(uvec3(hex >> 16u, hex >> 8u, hex) & 0xFFu, 255) / 255.0;
}

vec4 getSpeciesColor(uint i) {
    uint vec4Index = i / 4; // Which vec4 (0, 1, 2, or 3)
    uint component = i % 4; // Which component (0, 1, 2, or 3)
    return rgba(speciesColours[vec4Index][component]);
}

float sample_in_direction(uint agentID, float direction, vec4 speciesColour) {
    float sampleAngleDirection = agents[agentID].angle + (direction * sampleAngle * PI);
    ivec2 samplePos = ivec2(
        agents[agentID].x + int(sampleDist * cos(sampleAngleDirection)),
        agents[agentID].y + int(sampleDist * sin(sampleAngleDirection)) 
    );

    vec4 pixel = imageLoad(screenTexture, samplePos);
    return 1 - length(pixel.rgb - speciesColour.rgb); // 1 - sqrt(dx^2 + dy^2 + dz^2)
}

float choose_direction(uint agentID, vec4 speciesColour) {
    float s1 = sample_in_direction(agentID, LEFT,   speciesColour); 
    float s2 = sample_in_direction(agentID, CENTER, speciesColour);
    float s3 = sample_in_direction(agentID, RIGHT,  speciesColour);
    
    if (s1 == s2 || s2 == s3 || s1 == s3) return CENTER;
    
    // No ties, find the maximum
    if (s1 > s2 && s1 > s3) return LEFT;
    if (s3 > s2 && s3 > s1) return RIGHT;
    return CENTER;
}

void main() {
    uint agentID = gl_GlobalInvocationID.x;
    if (agentID >= numAgents) return;

    vec2 texSize = imageSize(screenTexture);
    agents[agentID].species = agentID % numSpecies;
    uint species = agents[agentID].species;
    vec4 colour = getSpeciesColor(species);
    uint rng = pcg_state_hash(agentID + frameNumber * 7919u);

    if (frameNumber == 0 || resetToCircle == 1u) {
        if (resetToCircle == 1u) {
            // Reset to circle formation
            vec2 center = texSize * 0.5;
            float radius = min(texSize.x, texSize.y) * 0.05;
            
            float circleAngle = pcg_next(rng, false) * 2 * PI;
            float circleRadius = sqrt(pcg_next(rng, false)) * radius;
            
            vec2 circlePos = center + vec2(cos(circleAngle), sin(circleAngle)) * circleRadius;
            vec2 outwardDir = normalize(circlePos - center);
            
            // Add some angle variation for better spreading
            float angleVariation = (pcg_next(rng, true) * 0.3); // ±0.3 radians (~±17 degrees)
            float finalAngle = atan(outwardDir.y, outwardDir.x) + angleVariation;
            
            agents[agentID].x = circlePos.x;
            agents[agentID].y = circlePos.y;
            agents[agentID].angle = finalAngle;
        } else {
            // Random initialization
            float rx = pcg_next(rng, false) * float(texSize.x);
            float ry = pcg_next(rng, false) * float(texSize.y);
            float rangle = pcg_next(rng, false) * 2 * PI;

            agents[agentID].x = rx;
            agents[agentID].y = ry;
            agents[agentID].angle = rangle;
        }
        return;
    }

    vec2 currentPos = vec2(agents[agentID].x, agents[agentID].y);
    vec2 movement = vec2(speed * cos(agents[agentID].angle), speed * sin(agents[agentID].angle));
    
    if (mousePressed == 1u) {
        vec2 mouseDir = currentPos - mousePos;
        float mouseDist = length(mouseDir);
        const float avoidanceRadius = 250.0;
        const float avoidanceStrength = 10.0;
        
        if (mouseDist < avoidanceRadius && mouseDist > 0.0) {
            vec2 avoidanceForce = normalize(mouseDir) * (avoidanceStrength * (avoidanceRadius - mouseDist) / avoidanceRadius);
            movement += avoidanceForce;
        }
    }
    
    if (rightMousePressed == 1u) {
        // Half the species are attracted to right mouse
        bool isAttracted = (species % 2) == 0;
        if (isAttracted) {
            vec2 mouseDir = mousePos - currentPos;
            float mouseDist = length(mouseDir);
            const float attractionRadius = 300.0;
            const float attractionStrength = 15.0;
            
            if (mouseDist < attractionRadius && mouseDist > 0.0) {
                vec2 attractionForce = normalize(mouseDir) * (attractionStrength * (attractionRadius - mouseDist) / attractionRadius);
                movement += attractionForce;
            }
        }
    }
    
    vec2 newPos = currentPos + movement;

    // Reflect if hitting/outside boundaries
    if (newPos.x >= texSize.x || newPos.x < 0.0) {
        agents[agentID].angle = PI - agents[agentID].angle;
        newPos.x = clamp(newPos.x, 0.0, texSize.x - 1.0);
    }
    if (newPos.y >= texSize.y || newPos.y < 0.0) {
        agents[agentID].angle = -agents[agentID].angle;
        newPos.y = clamp(newPos.y, 0.0, texSize.y - 1.0);
    }

    agents[agentID].x = newPos.x;
    agents[agentID].y = newPos.y;

    float direction = choose_direction(agentID, colour);
    agents[agentID].angle += ((direction * turnSpeed) + (turnRandomness * pcg_next(rng, true))) * 2 * PI;
    
    ivec2 texelCoord = ivec2(agents[agentID].x, agents[agentID].y);
    imageStore(screenTexture, texelCoord, colour);
}