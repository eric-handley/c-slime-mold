#version 430 core

#define PI 3.14159265359
#define LOCAL_SIZE 32

#define LEFT   float( 1.0)
#define CENTER float( 0.0)
#define RIGHT  float(-1.0)

const ivec2 sampleOffsets[3][3] = {
    {ivec2(-1,  1), ivec2(0,  1), ivec2(1,  1)},
    {ivec2(-1,  0), ivec2(0,  0), ivec2(1,  0)},
    {ivec2(-1, -1), ivec2(0, -1), ivec2(1, -1)}
};

layout (local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

layout (rgba32f, binding = 0) uniform image2D screenTexture;
layout (location = 0) uniform uint frameNumber;
layout (location = 1) uniform uint time;

struct Agent {
    float x;
    float y;
    float angle;
    uint species;
};

layout(std430, binding = 0) buffer AgentBuffer {
    Agent agents[];
};

layout(std140, binding = 0) uniform Settings {
    uint  numAgents;
    uint  numSpecies;
    uvec4 speciesColours[4];
    float speed;
    float turnRandomness;
    float turnSpeed;
    float sampleAngle;
    uint  sampleDist;
    uint  debug;
};

uint hash(uint x) {
    x += (x << 10u);
    x ^= (x >> 6u);
    x += (x << 3u);
    x ^= (x >> 11u);
    x += (x << 15u);
    return x;
}

uint pcg_state(uint seed) {
    return hash(seed + frameNumber + time);
}

float pcg_next(inout uint state, bool normalize_minus_one_to_one) {
    state = state * 1664525u + 1013904223u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    word = (word >> 22u) ^ word;
    if (normalize_minus_one_to_one) {
        float norm = float(word) * (1.0 / 4294967295.0);
        return (norm * 2.0 - 1.0);
    }
    return float(word) / 4294967295.0;
}

vec4 rgba(uint hex) {
    return vec4(uvec3(hex >> 16u, hex >> 8u, hex) & 0xFFu, 255) / 255.0;
}

uint hex(vec4 rgba) {
    uvec4 components = uvec4(rgba * 255.0 + 0.5);
    return (components.r << 16u) | (components.g << 8u) | components.b;
}

vec4 getSpeciesColor(uint i) {
    uint vec4Index = i / 4; // Which vec4 (0, 1, 2, or 3)
    uint component = i % 4; // Which component (0, 1, 2, or 3)
    return rgba(speciesColours[vec4Index][component]);
}

float sample_in_direction(uint agentID, float direction, vec4 speciesColour) {
    float sampleAngleDirection = agents[agentID].angle + (direction * sampleAngle);
    ivec2 center = ivec2(
        agents[agentID].x + int(sampleDist * cos(sampleAngleDirection)),
        agents[agentID].y + int(sampleDist * sin(sampleAngleDirection)) 
    );

    if (bool(debug)) imageStore(screenTexture, center, vec4(0,0,1,1));

    float sum = 0.0;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            ivec2 xy = center + sampleOffsets[i][j];
            vec4 pixel = imageLoad(screenTexture, xy);   

            vec3 delta = pixel.rgb - speciesColour.rgb;
            float distance = length(delta); // sqrt(dx^2 + dy^2 + dz^2)
            sum += 1.0 - distance; // smaller distance â†’ higher similarity
        }
    }

    return sum;
}

float choose_direction(uint agentID, vec4 speciesColour) {
    float s1 = sample_in_direction(agentID, LEFT,   speciesColour); 
    float s2 = sample_in_direction(agentID, CENTER, speciesColour);
    float s3 = sample_in_direction(agentID, RIGHT,  speciesColour);
    float sMax = max(max(s1, s2), s3); 

    if ((sMax == s1 && sMax == s2) || (sMax == s2 && sMax == s3) || (sMax == s1 && sMax == s2) || (sMax == 0)) {
        return float(CENTER);
    }
    
    if (s1 == sMax)
        return float(LEFT);
    if (s3 == sMax)
        return float(RIGHT);
    
    return float(CENTER);
}

void main() {
    uint agentID = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * (gl_NumWorkGroups.x * gl_WorkGroupSize.x);
    if (agentID >= numAgents) return;
    
    vec2 texSize = imageSize(screenTexture);
    uint species = agents[agentID].species;
    vec4 colour = getSpeciesColor(species);
    uint rng = pcg_state(agentID + frameNumber * 7919u);

    if (frameNumber == 0) {
        float rx = pcg_next(rng, false) * float(texSize.x);
        float ry = pcg_next(rng, false) * float(texSize.y);
        float rangle = pcg_next(rng, false) * 2 * PI;
        uint rspecies = agentID % numSpecies;

        agents[agentID].x = rx;
        agents[agentID].y = ry;
        agents[agentID].angle = rangle;
        agents[agentID].species = rspecies;
        return;
    }
    
    agents[agentID].x += speed * cos(agents[agentID].angle);
    agents[agentID].y += speed * sin(agents[agentID].angle);
    
    if (agents[agentID].x >= texSize.x) {
        agents[agentID].angle = PI - agents[agentID].angle; 
        agents[agentID].x = texSize.x - 1;
    }
    if (agents[agentID].x < 0) {
        agents[agentID].angle = PI - agents[agentID].angle; 
        agents[agentID].x = 0;
    }
    if (agents[agentID].y >= texSize.y) {
        agents[agentID].angle = -1 * agents[agentID].angle; 
        agents[agentID].y = texSize.y - 1;
    }
    if (agents[agentID].y < 0) {
        agents[agentID].angle = -1 * agents[agentID].angle; 
        agents[agentID].y = 0;
    }

    float direction = choose_direction(agentID, colour);

    
    ivec2 pixel = ivec2(
        agents[agentID].x + int(sampleDist * cos(agents[agentID].angle + (direction * sampleAngle))),
        agents[agentID].y + int(sampleDist * sin(agents[agentID].angle + (direction * sampleAngle))) 
    );

    if (bool(debug)) imageStore(screenTexture, pixel, vec4(1,0,0,1));
    
    agents[agentID].angle += ((direction * turnSpeed) + (turnRandomness * pcg_next(rng, true))) * 2 * PI;
    ivec2 texelCoord = ivec2(agents[agentID].x, agents[agentID].y);
    imageStore(screenTexture, texelCoord, colour);
}